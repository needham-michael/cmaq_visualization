{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CMAQ Python Visualizations Homepage for Python Visualizations and Analysis of CMAQ Data , a series of short examples of generating visualizations of input and output files from the US EPA Commmunity Multiscale Air Quality Model (CMAQ) using tools from the python ecosystem. These examples are provided for demonstrative purposes only. Most features of the example notebooks can be seen directly through the GitHub previews (the primary exception is for all interactive visualizations), but if you would like to run the notebooks yourself, see Getting Started for installation and setup instructions. Links and descriptions for each notebook are included on the Examples page. Issues and Requests If you have any problems, or would like to request a new example, you can open an issue on GitHub , or contact Michael Needham ( needham.michael@epa.gov ) Utils See the sidebar for some helpful utility functions. Like the rest of this package, these functions are provided as-is. License This open-source project is provided under the MIT License","title":"Home"},{"location":"#cmaq-python-visualizations","text":"Homepage for Python Visualizations and Analysis of CMAQ Data , a series of short examples of generating visualizations of input and output files from the US EPA Commmunity Multiscale Air Quality Model (CMAQ) using tools from the python ecosystem. These examples are provided for demonstrative purposes only. Most features of the example notebooks can be seen directly through the GitHub previews (the primary exception is for all interactive visualizations), but if you would like to run the notebooks yourself, see Getting Started for installation and setup instructions. Links and descriptions for each notebook are included on the Examples page.","title":"CMAQ Python Visualizations"},{"location":"#issues-and-requests","text":"If you have any problems, or would like to request a new example, you can open an issue on GitHub , or contact Michael Needham ( needham.michael@epa.gov )","title":"Issues and Requests"},{"location":"#utils","text":"See the sidebar for some helpful utility functions. Like the rest of this package, these functions are provided as-is.","title":"Utils"},{"location":"#license","text":"This open-source project is provided under the MIT License","title":"License"},{"location":"examples/","text":"Examples Warning Make sure you have followed the setup instructions on the Getting Started page before trying to run these examples locally. 1) Minimal CMAQ Plotting Example : Generate simple coordinate-aware maps of hourly Ozone and PM2.5 concentrations from a CMAQ simulation on the 36US3 grid. 2) Basic Analysis of hr2day output : Generate maps and timeseries plots of the daily maximum of 8-hour average ozone (MDA8O3) with additional colorbar customizations to highlight the value of 0.070 ppm, which is important for the primary 8-hour NAAQS for ozone. This notebook utilizes output files that were generated using the CMAQ hr2day postprocessing tool. 3) Model-Data Comparison : Download AQS in-situ air quality data using the pyRSIG package and compare to CMAQ hr2day output as in Example 2. 4) Edits to Emission Files : Demonstrate how to use xarray to make changes to NO and NO2 fields from a 12US1 CMAQ emission files. Auxiliary Examples Auxiliary examples either cover adjacent topics, or are included only for informational purposes because they rely on data files which are too large / too numerous to include in the tutorial data folder. A1) Concat files : Auxiliary example showing basic concatenation of files. A2) Download AQS data : Auxiliary example showing how to download AQS data that coincides with CMAQ output using pyRSIG . Also includes an example of plotting AQS monitor data on an interactive web map with folium . A3) Coordinate Transformations and Subsetting : Auxiliary example showing how to manage data in different coordinate systems. Makes use of cartopy for coordinate reference systems, as well as geopandas and shapely to manage points and polygons across coordinate systems.","title":"CMAQ Visualization Examples"},{"location":"examples/#examples","text":"Warning Make sure you have followed the setup instructions on the Getting Started page before trying to run these examples locally. 1) Minimal CMAQ Plotting Example : Generate simple coordinate-aware maps of hourly Ozone and PM2.5 concentrations from a CMAQ simulation on the 36US3 grid. 2) Basic Analysis of hr2day output : Generate maps and timeseries plots of the daily maximum of 8-hour average ozone (MDA8O3) with additional colorbar customizations to highlight the value of 0.070 ppm, which is important for the primary 8-hour NAAQS for ozone. This notebook utilizes output files that were generated using the CMAQ hr2day postprocessing tool. 3) Model-Data Comparison : Download AQS in-situ air quality data using the pyRSIG package and compare to CMAQ hr2day output as in Example 2. 4) Edits to Emission Files : Demonstrate how to use xarray to make changes to NO and NO2 fields from a 12US1 CMAQ emission files.","title":"Examples"},{"location":"examples/#auxiliary-examples","text":"Auxiliary examples either cover adjacent topics, or are included only for informational purposes because they rely on data files which are too large / too numerous to include in the tutorial data folder. A1) Concat files : Auxiliary example showing basic concatenation of files. A2) Download AQS data : Auxiliary example showing how to download AQS data that coincides with CMAQ output using pyRSIG . Also includes an example of plotting AQS monitor data on an interactive web map with folium . A3) Coordinate Transformations and Subsetting : Auxiliary example showing how to manage data in different coordinate systems. Makes use of cartopy for coordinate reference systems, as well as geopandas and shapely to manage points and polygons across coordinate systems.","title":"Auxiliary Examples"},{"location":"setup/","text":"Getting Started Getting the code The most up-to-date version of this repository including all tutorial data can be downloaded locally using git. You can \"get git\" onto your local machine directly from the git website , or it can be installed within a conda environment using conda install -c conda-forge git . Either way, once git is configured, you can download everything you need to run these examples with git clone https://github.com/needham-michael/cmaq_visualization.git This will create a directory called /cmaq_visualization on your local machine. Preparing the python environment The environment.yml file includes instructions for recreating the same conda environment (named cmaq_pyenv ) used to develop and run these notebooks. Assuming conda has been installed locally and initialized for the user's shell, the environment can be recreated by running the following command from within the base directory conda env create -f environment.yml The environment can then be activated with conda activate cmaq_pyenv Adding the ipython kernel to Jupyter Once the environment has been created, Jupyter needs to be configured to execute the notebooks using the environment. This requires using the ipykernel package, which was included in the environment.yml file. From the terminal window, run python3 -m ipykernel install --user --name=cmaq_pyenv --display-name=\"Python3 (cmaq_pyenv)\" Installing the project package You will need to install the python utility functions into the cmaq_pyenv conda environment by running pip install . from the /cmaq_visualiztion folder (make sure that the correct conda environment is selected). If you plan to make your own changes to those utility functions (or add new ones), change that command to pip install . -e so that it is editible . Note If you do make edits to the utility functions (or add your own), you may also want to add the following cell magic comamands to the notebooks: %load_ext autoreload , and %autoreload 2 , which can just be placed in a cell at the top of the notebook and run once. This will allow you to make changes to the source code and have those changes immediately become available within the Jupyter notebook without the need to restart the kernel.","title":"Getting Started"},{"location":"setup/#getting-started","text":"","title":"Getting Started"},{"location":"setup/#getting-the-code","text":"The most up-to-date version of this repository including all tutorial data can be downloaded locally using git. You can \"get git\" onto your local machine directly from the git website , or it can be installed within a conda environment using conda install -c conda-forge git . Either way, once git is configured, you can download everything you need to run these examples with git clone https://github.com/needham-michael/cmaq_visualization.git This will create a directory called /cmaq_visualization on your local machine.","title":"Getting the code"},{"location":"setup/#preparing-the-python-environment","text":"The environment.yml file includes instructions for recreating the same conda environment (named cmaq_pyenv ) used to develop and run these notebooks. Assuming conda has been installed locally and initialized for the user's shell, the environment can be recreated by running the following command from within the base directory conda env create -f environment.yml The environment can then be activated with conda activate cmaq_pyenv","title":"Preparing the python environment"},{"location":"setup/#adding-the-ipython-kernel-to-jupyter","text":"Once the environment has been created, Jupyter needs to be configured to execute the notebooks using the environment. This requires using the ipykernel package, which was included in the environment.yml file. From the terminal window, run python3 -m ipykernel install --user --name=cmaq_pyenv --display-name=\"Python3 (cmaq_pyenv)\"","title":"Adding the ipython kernel to Jupyter"},{"location":"setup/#installing-the-project-package","text":"You will need to install the python utility functions into the cmaq_pyenv conda environment by running pip install . from the /cmaq_visualiztion folder (make sure that the correct conda environment is selected). If you plan to make your own changes to those utility functions (or add new ones), change that command to pip install . -e so that it is editible . Note If you do make edits to the utility functions (or add your own), you may also want to add the following cell magic comamands to the notebooks: %load_ext autoreload , and %autoreload 2 , which can just be placed in a cell at the top of the notebook and run once. This will allow you to make changes to the source code and have those changes immediately become available within the Jupyter notebook without the need to restart the kernel.","title":"Installing the project package"},{"location":"api-reference/utils/cartopy/","text":"Cartopy Utilities Utility functions for working with Cartopy default_map ( ax , extent = None , scale = '110m' , ec = 'k' , lw = 0.75 ) Draw basic features onto a map Parameters: ax ( GeoAxes ) \u2013 Target axis for drawing features extent ( list , default: = [-130,-65,25,55] ) \u2013 Map extent in [minlon,maxlon,minlat,maxlat] passed to ax.set_extent scale ( str , default: = '110m' ) \u2013 Scale of drawn features. Options: ['10m', '50m', '110m'] Source code in src/utils/cartopy.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def default_map ( ax , extent = None , scale = \"110m\" , ec = \"k\" , lw = 0.75 ): \"\"\"Draw basic features onto a map Parameters ---------- ax : cartopy.mpl.geoaxes.GeoAxes Target axis for drawing features extent : list, default = [-130,-65,25,55] Map extent in [minlon,maxlon,minlat,maxlat] passed to ax.set_extent scale : str, default = '110m' Scale of drawn features. Options: ['10m', '50m', '110m'] \"\"\" if extent is None : extent = [ - 130 , - 65 , 25 , 55 ] ax . set_extent ( extent , crs = ccrs . PlateCarree ()) ax . add_feature ( cfeature . BORDERS . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) ax . add_feature ( cfeature . LAKES . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) ax . add_feature ( cfeature . STATES . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) ax . add_feature ( cfeature . OCEAN . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) return None map_tiles ( ax , zoom = None ) Add open street map tiles to a map Parameters: ax ( GeoAxes ) \u2013 Target axis for drawing features zoom ( int , default: = None ) \u2013 Zoom level for the map. Source code in src/utils/cartopy.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def map_tiles ( ax , zoom = None ): \"\"\"Add open street map tiles to a map Parameters ---------- ax : cartopy.mpl.geoaxes.GeoAxes Target axis for drawing features zoom : int, default = None Zoom level for the map. \"\"\" if zoom is None : raise ValueError ( \"Need to specify a zoom level\" ) tiles = cimgt . OSM ( cache = True ) ax . add_image ( tiles , zoom , interpolation = \"spline36\" , regrid_shape = 2000 ) return None","title":"cartopy"},{"location":"api-reference/utils/cartopy/#cartopy-utilities","text":"Utility functions for working with Cartopy","title":"Cartopy Utilities"},{"location":"api-reference/utils/cartopy/#src.utils.cartopy.default_map","text":"Draw basic features onto a map Parameters: ax ( GeoAxes ) \u2013 Target axis for drawing features extent ( list , default: = [-130,-65,25,55] ) \u2013 Map extent in [minlon,maxlon,minlat,maxlat] passed to ax.set_extent scale ( str , default: = '110m' ) \u2013 Scale of drawn features. Options: ['10m', '50m', '110m'] Source code in src/utils/cartopy.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def default_map ( ax , extent = None , scale = \"110m\" , ec = \"k\" , lw = 0.75 ): \"\"\"Draw basic features onto a map Parameters ---------- ax : cartopy.mpl.geoaxes.GeoAxes Target axis for drawing features extent : list, default = [-130,-65,25,55] Map extent in [minlon,maxlon,minlat,maxlat] passed to ax.set_extent scale : str, default = '110m' Scale of drawn features. Options: ['10m', '50m', '110m'] \"\"\" if extent is None : extent = [ - 130 , - 65 , 25 , 55 ] ax . set_extent ( extent , crs = ccrs . PlateCarree ()) ax . add_feature ( cfeature . BORDERS . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) ax . add_feature ( cfeature . LAKES . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) ax . add_feature ( cfeature . STATES . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) ax . add_feature ( cfeature . OCEAN . with_scale ( scale ), ec = ec , fc = \"none\" , lw = lw ) return None","title":"default_map"},{"location":"api-reference/utils/cartopy/#src.utils.cartopy.map_tiles","text":"Add open street map tiles to a map Parameters: ax ( GeoAxes ) \u2013 Target axis for drawing features zoom ( int , default: = None ) \u2013 Zoom level for the map. Source code in src/utils/cartopy.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def map_tiles ( ax , zoom = None ): \"\"\"Add open street map tiles to a map Parameters ---------- ax : cartopy.mpl.geoaxes.GeoAxes Target axis for drawing features zoom : int, default = None Zoom level for the map. \"\"\" if zoom is None : raise ValueError ( \"Need to specify a zoom level\" ) tiles = cimgt . OSM ( cache = True ) ax . add_image ( tiles , zoom , interpolation = \"spline36\" , regrid_shape = 2000 ) return None","title":"map_tiles"},{"location":"api-reference/utils/cmaq/","text":"CMAQ Utilities Utility functions for working with CMAQ output drop_cmaq_metadata ( dset ) Remove metadata and reset to original IOAPI conventions Drop all metadata additions made to dataset by get_cmaq_metadata Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a file in cmaq format Returns: dset ( Dataset ) \u2013 the same input dataset, but coordinate arrays dropped See Also get_cmaq_metadata Source code in src/utils/cmaq.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def drop_cmaq_metadata ( dset ): \"\"\"Remove metadata and reset to original IOAPI conventions Drop all metadata additions made to dataset by get_cmaq_metadata Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a file in cmaq format Returns ------- dset : xarray.Dataset the same input dataset, but coordinate arrays dropped See Also -------- get_cmaq_metadata \"\"\" # Drop projection-aware x and y coordinates, and datetime-aware time coord dset = dset . drop_vars ([ \"x\" , \"y\" , \"time\" ]) # Rename back to IOAPI convention dset = dset . rename_dims ( { \"time\" : \"TSTEP\" , \"x\" : \"COL\" , \"y\" : \"ROW\" , } ) # Ensure there is a length-1 \"LAY\" dimension if \"LAY\" not in list ( dset . dims ): dset = dset . expand_dims ( dim = \"LAY\" , axis = 1 ) return dset get_cmaq_datetime ( dset , is_jday = True ) Generate datetime coordinate array for cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a file in cmaq format is_jday ( bool , default: True ) \u2013 flag to indicate if input dates use the Julian (YYYYJJJ) or the Gregorian (YYYYMMDD) calendar format. Note that even if is_jday=True, the resulting datetime coordinate array will use the defauly pandas gregorian calendar. In other words, this flag is only used to interpret input dates, not to set output dates. Returns: datetimes ( Series ) \u2013 datetime coordinate array, parsed to pandas gregorian datetime format. Source code in src/utils/cmaq.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def get_cmaq_datetime ( dset , is_jday = True ): \"\"\"Generate datetime coordinate array for cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a file in cmaq format is_jday : bool, default=True flag to indicate if input dates use the Julian (YYYYJJJ) or the Gregorian (YYYYMMDD) calendar format. Note that even if is_jday=True, the resulting datetime coordinate array will use the defauly pandas gregorian calendar. In other words, this flag is only used to interpret input dates, not to set output dates. Returns ------- datetimes : pandas.Series datetime coordinate array, parsed to pandas gregorian datetime format. \"\"\" ntstep = len ( dset . TSTEP ) times = np . arange ( dset . attrs [ \"STIME\" ], dset . attrs [ \"TSTEP\" ] * ntstep , dset . attrs [ \"TSTEP\" ] ) start_date = dset . attrs [ \"SDATE\" ] date_inc = - 1 datetimes = [] for time in times % 240000 : if time == 0 : date_inc += 1 datetimes . append ( f \" { start_date + date_inc } T { time : 0>6 } \" ) if is_jday : date_format = \"%Y%jT%H%M%S\" else : date_format = \"%Y%m %d T%H%M%S\" datetimes = pd . to_datetime ( datetimes , format = date_format ) return datetimes get_cmaq_metadata ( dset , is_jday = True , return_proj = False ) Interpret and add coordinate arrays to cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a file in cmaq format is_jday ( bool , default: True ) \u2013 parameter passed to get_cmaq_datetime() Returns: dset ( Dataset ) \u2013 the same input dataset, but with added coordinate arrays proj_lamb ( LambertConformal ) \u2013 a cartopy Lambert conformal conic projection with parameters set by the input dataset attributes, for use in plotting See Also drop_cmaq_metadata Source code in src/utils/cmaq.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_cmaq_metadata ( dset , is_jday = True , return_proj = False ): \"\"\"Interpret and add coordinate arrays to cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a file in cmaq format is_jday : bool, default=True parameter passed to get_cmaq_datetime() Returns ------- dset : xarray.Dataset the same input dataset, but with added coordinate arrays proj_lamb : cartopy.crs.LambertConformal a cartopy Lambert conformal conic projection with parameters set by the input dataset attributes, for use in plotting See Also -------- drop_cmaq_metadata \"\"\" # Get coordinate arrays associated with the x-, y-, and time-dimensions xcoords , ycoords = get_cmaq_xy ( dset ) datetimes = get_cmaq_datetime ( dset , is_jday = is_jday ) # Add the coordinate arrays and rename the output dset = dset . assign_coords ({ \"COL\" : xcoords , \"ROW\" : ycoords , \"TSTEP\" : datetimes }) dset = dset . rename ({ \"ROW\" : \"y\" , \"COL\" : \"x\" , \"TSTEP\" : \"time\" }) if return_proj : proj = get_cmaq_projection ( dset ) return dset , proj return dset get_cmaq_projection ( dset , proj_type = 'lambert' ) Create a cartopy lambert projection object from dataset metadata Source code in src/utils/cmaq.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_cmaq_projection ( dset , proj_type = \"lambert\" ): \"\"\"Create a cartopy lambert projection object from dataset metadata\"\"\" if proj_type == \"lambert\" : # Generate the projection proj = ccrs . LambertConformal ( central_latitude = dset . attrs [ \"YCENT\" ], central_longitude = dset . attrs [ \"XCENT\" ], standard_parallels = ( dset . attrs [ \"P_ALP\" ], dset . attrs [ \"P_BET\" ]), false_easting =- dset . attrs [ \"XORIG\" ], false_northing =- dset . attrs [ \"YORIG\" ], ) elif ( proj_type == \"mercator\" ) or ( proj_type == \"polar\" ): raise NotImplementedError ( f 'projection: \" { proj_type } \" not yet implemented' ) else : raise ValueError ( f \"\"\" Invalid projection: { proj_type } . Choose a valid projection: [ \\' lambert \\' , \\' mercator \\' , \\' polar \\' ] \"\"\" ) return proj get_cmaq_xy ( dset ) Generate x and y coordinate arrays for cmaq-formatted data Interpret attributes of the input file to generate x and y coordinate arrays based on the number of gridcells in the x- and y-directions, and the size of the gridcells in in those directions (which will typically be identical, but in general could be different). Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a netcdf file in cmaq format Returns: xcoords ( array ) \u2013 coordinate array for the x dimension ycoords ( array ) \u2013 coordinate array for the y dimension Source code in src/utils/cmaq.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def get_cmaq_xy ( dset ): \"\"\"Generate x and y coordinate arrays for cmaq-formatted data Interpret attributes of the input file to generate x and y coordinate arrays based on the number of gridcells in the x- and y-directions, and the size of the gridcells in in those directions (which will typically be identical, but in general could be different). Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a netcdf file in cmaq format Returns ------- xcoords : numpy.array coordinate array for the x dimension ycoords : numpy.array coordinate array for the y dimension \"\"\" xcoords = np . arange ( 0 , ( dset . attrs [ \"XCELL\" ] * dset . attrs [ \"NCOLS\" ]), dset . attrs [ \"XCELL\" ] ) ycoords = np . arange ( 0 , dset . attrs [ \"YCELL\" ] * dset . attrs [ \"NROWS\" ], dset . attrs [ \"YCELL\" ] ) return xcoords , ycoords","title":"cmaq"},{"location":"api-reference/utils/cmaq/#cmaq-utilities","text":"Utility functions for working with CMAQ output","title":"CMAQ Utilities"},{"location":"api-reference/utils/cmaq/#src.utils.cmaq.drop_cmaq_metadata","text":"Remove metadata and reset to original IOAPI conventions Drop all metadata additions made to dataset by get_cmaq_metadata Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a file in cmaq format Returns: dset ( Dataset ) \u2013 the same input dataset, but coordinate arrays dropped See Also get_cmaq_metadata Source code in src/utils/cmaq.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def drop_cmaq_metadata ( dset ): \"\"\"Remove metadata and reset to original IOAPI conventions Drop all metadata additions made to dataset by get_cmaq_metadata Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a file in cmaq format Returns ------- dset : xarray.Dataset the same input dataset, but coordinate arrays dropped See Also -------- get_cmaq_metadata \"\"\" # Drop projection-aware x and y coordinates, and datetime-aware time coord dset = dset . drop_vars ([ \"x\" , \"y\" , \"time\" ]) # Rename back to IOAPI convention dset = dset . rename_dims ( { \"time\" : \"TSTEP\" , \"x\" : \"COL\" , \"y\" : \"ROW\" , } ) # Ensure there is a length-1 \"LAY\" dimension if \"LAY\" not in list ( dset . dims ): dset = dset . expand_dims ( dim = \"LAY\" , axis = 1 ) return dset","title":"drop_cmaq_metadata"},{"location":"api-reference/utils/cmaq/#src.utils.cmaq.get_cmaq_datetime","text":"Generate datetime coordinate array for cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a file in cmaq format is_jday ( bool , default: True ) \u2013 flag to indicate if input dates use the Julian (YYYYJJJ) or the Gregorian (YYYYMMDD) calendar format. Note that even if is_jday=True, the resulting datetime coordinate array will use the defauly pandas gregorian calendar. In other words, this flag is only used to interpret input dates, not to set output dates. Returns: datetimes ( Series ) \u2013 datetime coordinate array, parsed to pandas gregorian datetime format. Source code in src/utils/cmaq.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def get_cmaq_datetime ( dset , is_jday = True ): \"\"\"Generate datetime coordinate array for cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a file in cmaq format is_jday : bool, default=True flag to indicate if input dates use the Julian (YYYYJJJ) or the Gregorian (YYYYMMDD) calendar format. Note that even if is_jday=True, the resulting datetime coordinate array will use the defauly pandas gregorian calendar. In other words, this flag is only used to interpret input dates, not to set output dates. Returns ------- datetimes : pandas.Series datetime coordinate array, parsed to pandas gregorian datetime format. \"\"\" ntstep = len ( dset . TSTEP ) times = np . arange ( dset . attrs [ \"STIME\" ], dset . attrs [ \"TSTEP\" ] * ntstep , dset . attrs [ \"TSTEP\" ] ) start_date = dset . attrs [ \"SDATE\" ] date_inc = - 1 datetimes = [] for time in times % 240000 : if time == 0 : date_inc += 1 datetimes . append ( f \" { start_date + date_inc } T { time : 0>6 } \" ) if is_jday : date_format = \"%Y%jT%H%M%S\" else : date_format = \"%Y%m %d T%H%M%S\" datetimes = pd . to_datetime ( datetimes , format = date_format ) return datetimes","title":"get_cmaq_datetime"},{"location":"api-reference/utils/cmaq/#src.utils.cmaq.get_cmaq_metadata","text":"Interpret and add coordinate arrays to cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a file in cmaq format is_jday ( bool , default: True ) \u2013 parameter passed to get_cmaq_datetime() Returns: dset ( Dataset ) \u2013 the same input dataset, but with added coordinate arrays proj_lamb ( LambertConformal ) \u2013 a cartopy Lambert conformal conic projection with parameters set by the input dataset attributes, for use in plotting See Also drop_cmaq_metadata Source code in src/utils/cmaq.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_cmaq_metadata ( dset , is_jday = True , return_proj = False ): \"\"\"Interpret and add coordinate arrays to cmaq-formatted data Interpret attributes of the input file to generate datetime coordinate array based on the number of timesteps, the size of the timestep, and the starting date and time Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a file in cmaq format is_jday : bool, default=True parameter passed to get_cmaq_datetime() Returns ------- dset : xarray.Dataset the same input dataset, but with added coordinate arrays proj_lamb : cartopy.crs.LambertConformal a cartopy Lambert conformal conic projection with parameters set by the input dataset attributes, for use in plotting See Also -------- drop_cmaq_metadata \"\"\" # Get coordinate arrays associated with the x-, y-, and time-dimensions xcoords , ycoords = get_cmaq_xy ( dset ) datetimes = get_cmaq_datetime ( dset , is_jday = is_jday ) # Add the coordinate arrays and rename the output dset = dset . assign_coords ({ \"COL\" : xcoords , \"ROW\" : ycoords , \"TSTEP\" : datetimes }) dset = dset . rename ({ \"ROW\" : \"y\" , \"COL\" : \"x\" , \"TSTEP\" : \"time\" }) if return_proj : proj = get_cmaq_projection ( dset ) return dset , proj return dset","title":"get_cmaq_metadata"},{"location":"api-reference/utils/cmaq/#src.utils.cmaq.get_cmaq_projection","text":"Create a cartopy lambert projection object from dataset metadata Source code in src/utils/cmaq.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_cmaq_projection ( dset , proj_type = \"lambert\" ): \"\"\"Create a cartopy lambert projection object from dataset metadata\"\"\" if proj_type == \"lambert\" : # Generate the projection proj = ccrs . LambertConformal ( central_latitude = dset . attrs [ \"YCENT\" ], central_longitude = dset . attrs [ \"XCENT\" ], standard_parallels = ( dset . attrs [ \"P_ALP\" ], dset . attrs [ \"P_BET\" ]), false_easting =- dset . attrs [ \"XORIG\" ], false_northing =- dset . attrs [ \"YORIG\" ], ) elif ( proj_type == \"mercator\" ) or ( proj_type == \"polar\" ): raise NotImplementedError ( f 'projection: \" { proj_type } \" not yet implemented' ) else : raise ValueError ( f \"\"\" Invalid projection: { proj_type } . Choose a valid projection: [ \\' lambert \\' , \\' mercator \\' , \\' polar \\' ] \"\"\" ) return proj","title":"get_cmaq_projection"},{"location":"api-reference/utils/cmaq/#src.utils.cmaq.get_cmaq_xy","text":"Generate x and y coordinate arrays for cmaq-formatted data Interpret attributes of the input file to generate x and y coordinate arrays based on the number of gridcells in the x- and y-directions, and the size of the gridcells in in those directions (which will typically be identical, but in general could be different). Parameters: dset ( Dataset ) \u2013 result of calling xr.open_dataset() on a netcdf file in cmaq format Returns: xcoords ( array ) \u2013 coordinate array for the x dimension ycoords ( array ) \u2013 coordinate array for the y dimension Source code in src/utils/cmaq.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def get_cmaq_xy ( dset ): \"\"\"Generate x and y coordinate arrays for cmaq-formatted data Interpret attributes of the input file to generate x and y coordinate arrays based on the number of gridcells in the x- and y-directions, and the size of the gridcells in in those directions (which will typically be identical, but in general could be different). Parameters ---------- dset : xarray.Dataset result of calling xr.open_dataset() on a netcdf file in cmaq format Returns ------- xcoords : numpy.array coordinate array for the x dimension ycoords : numpy.array coordinate array for the y dimension \"\"\" xcoords = np . arange ( 0 , ( dset . attrs [ \"XCELL\" ] * dset . attrs [ \"NCOLS\" ]), dset . attrs [ \"XCELL\" ] ) ycoords = np . arange ( 0 , dset . attrs [ \"YCELL\" ] * dset . attrs [ \"NROWS\" ], dset . attrs [ \"YCELL\" ] ) return xcoords , ycoords","title":"get_cmaq_xy"},{"location":"api-reference/utils/matplotlib/","text":"Matplotlib Utilities Utility functions for working with Matplotlib discrete_colorbar ( vmin , vmax , dlev = None , cmap = 'inferno' , set_bad = None , set_over = None , set_under = None , display_boundaries = False , display_colorbar = False ) Make a discrete colorbar based on specified range and step size Parameters: vmin ( int or float ) \u2013 lower boundary for colorbar vmax ( int or float ) \u2013 upper boundary for colorbar dlev ( int or float , default: = None ) \u2013 spacing between color bounds. If None, spacing is chosen to give a colorbar with 12 evenly-spaced colors cmap ( str or Colormap , default: = 'inferno' ) \u2013 If a string, is name pointing to a Matplotlib colormap. For default options, see https://matplotlib.org/stable/users/explain/colors/colormaps.html Otherwise, used as an already-created colormap set_bad ( str , default: = None ) \u2013 Fill color to use for NaN values set_over ( str , default: = None ) \u2013 Fill color to use for values greater than vmax. set_under ( str , default: = None ) \u2013 Fill color to use for values less than vmin display_boundaries ( bool , default: = False ) \u2013 if True, printout the boundaries between colors display_colorbar ( bool , default: = False ) \u2013 if True, generate a plot to display the colorbar Returns: smap ( ScalarMappable ) \u2013 Object used to map data to desired colormap. Can access the underlying colormap with smap.cmap and the underlying norm with smap.norm Source code in src/utils/matplotlib.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def discrete_colorbar ( vmin , vmax , dlev = None , cmap = \"inferno\" , set_bad = None , set_over = None , set_under = None , display_boundaries = False , display_colorbar = False , ): \"\"\"Make a discrete colorbar based on specified range and step size Parameters ---------- vmin : int or float lower boundary for colorbar vmax : int or float upper boundary for colorbar dlev : int or float, default = None spacing between color bounds. If None, spacing is chosen to give a colorbar with 12 evenly-spaced colors cmap : str or matplotlib.colors.Colormap, default = 'inferno' If a string, is name pointing to a Matplotlib colormap. For default options, see https://matplotlib.org/stable/users/explain/colors/colormaps.html Otherwise, used as an already-created colormap set_bad : str, default = None Fill color to use for NaN values set_over : str, default = None Fill color to use for values greater than vmax. set_under : str, default = None Fill color to use for values less than vmin display_boundaries : bool, default = False if True, printout the boundaries between colors display_colorbar : bool, default = False if True, generate a plot to display the colorbar Returns ---------- smap : matplotlib.cm.ScalarMappable Object used to map data to desired colormap. Can access the underlying colormap with `smap.cmap` and the underlying norm with `smap.norm` \"\"\" if dlev is None : dlev = np . diff ( np . linspace ( vmin , vmax , 12 ))[ 0 ] cmap_boundaries = np . arange ( vmin , vmax + dlev / 2 , dlev ) if isinstance ( cmap , str ): cmap = mpl . colormaps [ cmap ] if set_bad is not None : cmap . set_bad ( set_bad ) if set_under is not None : cmap . set_under ( set_under ) if set_over is not None : cmap . set_over ( set_over ) norm = mpl . colors . BoundaryNorm ( ncolors = cmap . N , boundaries = cmap_boundaries ) smap = mpl . cm . ScalarMappable ( cmap = cmap , norm = norm ) if display_boundaries : print ( cmap_boundaries ) if display_colorbar : fig , ax = plt . subplots ( figsize = ( 6 , 0.3 )) fig . colorbar ( smap , cax = ax , orientation = \"horizontal\" ) plt . show () return smap","title":"matplotlib"},{"location":"api-reference/utils/matplotlib/#matplotlib-utilities","text":"Utility functions for working with Matplotlib","title":"Matplotlib Utilities"},{"location":"api-reference/utils/matplotlib/#src.utils.matplotlib.discrete_colorbar","text":"Make a discrete colorbar based on specified range and step size Parameters: vmin ( int or float ) \u2013 lower boundary for colorbar vmax ( int or float ) \u2013 upper boundary for colorbar dlev ( int or float , default: = None ) \u2013 spacing between color bounds. If None, spacing is chosen to give a colorbar with 12 evenly-spaced colors cmap ( str or Colormap , default: = 'inferno' ) \u2013 If a string, is name pointing to a Matplotlib colormap. For default options, see https://matplotlib.org/stable/users/explain/colors/colormaps.html Otherwise, used as an already-created colormap set_bad ( str , default: = None ) \u2013 Fill color to use for NaN values set_over ( str , default: = None ) \u2013 Fill color to use for values greater than vmax. set_under ( str , default: = None ) \u2013 Fill color to use for values less than vmin display_boundaries ( bool , default: = False ) \u2013 if True, printout the boundaries between colors display_colorbar ( bool , default: = False ) \u2013 if True, generate a plot to display the colorbar Returns: smap ( ScalarMappable ) \u2013 Object used to map data to desired colormap. Can access the underlying colormap with smap.cmap and the underlying norm with smap.norm Source code in src/utils/matplotlib.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def discrete_colorbar ( vmin , vmax , dlev = None , cmap = \"inferno\" , set_bad = None , set_over = None , set_under = None , display_boundaries = False , display_colorbar = False , ): \"\"\"Make a discrete colorbar based on specified range and step size Parameters ---------- vmin : int or float lower boundary for colorbar vmax : int or float upper boundary for colorbar dlev : int or float, default = None spacing between color bounds. If None, spacing is chosen to give a colorbar with 12 evenly-spaced colors cmap : str or matplotlib.colors.Colormap, default = 'inferno' If a string, is name pointing to a Matplotlib colormap. For default options, see https://matplotlib.org/stable/users/explain/colors/colormaps.html Otherwise, used as an already-created colormap set_bad : str, default = None Fill color to use for NaN values set_over : str, default = None Fill color to use for values greater than vmax. set_under : str, default = None Fill color to use for values less than vmin display_boundaries : bool, default = False if True, printout the boundaries between colors display_colorbar : bool, default = False if True, generate a plot to display the colorbar Returns ---------- smap : matplotlib.cm.ScalarMappable Object used to map data to desired colormap. Can access the underlying colormap with `smap.cmap` and the underlying norm with `smap.norm` \"\"\" if dlev is None : dlev = np . diff ( np . linspace ( vmin , vmax , 12 ))[ 0 ] cmap_boundaries = np . arange ( vmin , vmax + dlev / 2 , dlev ) if isinstance ( cmap , str ): cmap = mpl . colormaps [ cmap ] if set_bad is not None : cmap . set_bad ( set_bad ) if set_under is not None : cmap . set_under ( set_under ) if set_over is not None : cmap . set_over ( set_over ) norm = mpl . colors . BoundaryNorm ( ncolors = cmap . N , boundaries = cmap_boundaries ) smap = mpl . cm . ScalarMappable ( cmap = cmap , norm = norm ) if display_boundaries : print ( cmap_boundaries ) if display_colorbar : fig , ax = plt . subplots ( figsize = ( 6 , 0.3 )) fig . colorbar ( smap , cax = ax , orientation = \"horizontal\" ) plt . show () return smap","title":"discrete_colorbar"},{"location":"api-reference/utils/proj/","text":"Xarray Utilities Utility functions for working with cartopy projections proj_transform ( point_start , proj_final , proj_start = ccrs . PlateCarree ()) Perform a coordinate transformation for a point between two projections Source code in src/utils/proj.py 8 9 10 11 12 13 14 15 16 17 18 19 20 def proj_transform ( point_start , proj_final , proj_start = ccrs . PlateCarree ()): \"\"\"Perform a coordinate transformation for a point between two projections\"\"\" x0 , y0 = point_start pt_start = gpd . GeoDataFrame ( geometry = [ shapely . Point ( x0 , y0 )], crs = proj_start ) pt_final = pt_start . to_crs ( proj_final ) xf = pt_final [ \"geometry\" ] . iloc [ 0 ] . x yf = pt_final [ \"geometry\" ] . iloc [ 0 ] . y return ( xf , yf )","title":"proj"},{"location":"api-reference/utils/proj/#xarray-utilities","text":"Utility functions for working with cartopy projections","title":"Xarray Utilities"},{"location":"api-reference/utils/proj/#src.utils.proj.proj_transform","text":"Perform a coordinate transformation for a point between two projections Source code in src/utils/proj.py 8 9 10 11 12 13 14 15 16 17 18 19 20 def proj_transform ( point_start , proj_final , proj_start = ccrs . PlateCarree ()): \"\"\"Perform a coordinate transformation for a point between two projections\"\"\" x0 , y0 = point_start pt_start = gpd . GeoDataFrame ( geometry = [ shapely . Point ( x0 , y0 )], crs = proj_start ) pt_final = pt_start . to_crs ( proj_final ) xf = pt_final [ \"geometry\" ] . iloc [ 0 ] . x yf = pt_final [ \"geometry\" ] . iloc [ 0 ] . y return ( xf , yf )","title":"proj_transform"},{"location":"api-reference/utils/xarray/","text":"Xarray Utilities Utility functions for working with xarray data types display_vars ( dset , var_dsec = 'var_desc' , str_incl = None , str_excl = None ) Displays variables, units, and descriptions of an xarray dataset Generates a printout of each variable within dset that includes the variable name, the units, and an extended description of the variable (if available). Parameters: dset ( Dataset ) \u2013 Target dataset. It is possible to call display_vars on an unformatted dset e.g., display_vars(xr.open_dataset(file)), or on a formatted dset e.g., display_vars(get_cmaq_metadata(xr.open_dataset(file))). var_dsec ( string , default: 'var_desc' ) \u2013 Name of the attribute for the xarray.DataArray instances within dset which contains a description of the variable. str_incl ( string , default: None ) \u2013 String pattern to use for filtering. Only printout variables which include this pattern. str_excl ( string , default: None ) \u2013 String pattern to use for filtering. Only printout variables which do not include this pattern. Returns: None \u2013 See Also cmaq.get_cmaq_metadata Source code in src/utils/xarray.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def display_vars ( dset , var_dsec = \"var_desc\" , str_incl = None , str_excl = None ): \"\"\"Displays variables, units, and descriptions of an xarray dataset Generates a printout of each variable within dset that includes the variable name, the units, and an extended description of the variable (if available). Parameters ---------- dset : xarray.Dataset Target dataset. It is possible to call `display_vars` on an unformatted `dset` e.g., display_vars(xr.open_dataset(file)), or on a formatted `dset` e.g., display_vars(get_cmaq_metadata(xr.open_dataset(file))). var_dsec : string, default='var_desc' Name of the attribute for the xarray.DataArray instances within `dset` which contains a description of the variable. str_incl : string, default=None String pattern to use for filtering. Only printout variables which include this pattern. str_excl : string, default=None String pattern to use for filtering. Only printout variables which do not include this pattern. Returns ------- None See Also ------- cmaq.get_cmaq_metadata \"\"\" data_vars = [ x . strip () for x in dset . data_vars ] # Perform filtering of data variables if str_incl is not None : print ( f \"Including Pattern: { str_incl } \" ) data_vars = [ x for x in data_vars if str_incl in x ] if str_excl is not None : print ( f \"Excluding Pattern: { str_excl } \" ) data_vars = [ x for x in data_vars if str_excl not in x ] var = \"VARNAME\" units = \"UNITS\" desc = \"DESCRIPTION\" print ( \"-\" * 80 ) print ( f \"| { var : 16 } | { units : 16 } | { desc } \" ) print ( \"-\" * 80 ) ct = 1 for var in data_vars : desc = \"\" units = \"\" try : desc = getattr ( dset [ var ], var_dsec ) except Exception : pass try : units = dset [ var ] . units except Exception : pass print ( f \"| { var : 16 } | { units : 16 } | { desc } \" ) if ct % 6 == 0 : print ( \"-\" * 80 ) ct += 1 return None","title":"xarray"},{"location":"api-reference/utils/xarray/#xarray-utilities","text":"Utility functions for working with xarray data types","title":"Xarray Utilities"},{"location":"api-reference/utils/xarray/#src.utils.xarray.display_vars","text":"Displays variables, units, and descriptions of an xarray dataset Generates a printout of each variable within dset that includes the variable name, the units, and an extended description of the variable (if available). Parameters: dset ( Dataset ) \u2013 Target dataset. It is possible to call display_vars on an unformatted dset e.g., display_vars(xr.open_dataset(file)), or on a formatted dset e.g., display_vars(get_cmaq_metadata(xr.open_dataset(file))). var_dsec ( string , default: 'var_desc' ) \u2013 Name of the attribute for the xarray.DataArray instances within dset which contains a description of the variable. str_incl ( string , default: None ) \u2013 String pattern to use for filtering. Only printout variables which include this pattern. str_excl ( string , default: None ) \u2013 String pattern to use for filtering. Only printout variables which do not include this pattern. Returns: None \u2013 See Also cmaq.get_cmaq_metadata Source code in src/utils/xarray.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def display_vars ( dset , var_dsec = \"var_desc\" , str_incl = None , str_excl = None ): \"\"\"Displays variables, units, and descriptions of an xarray dataset Generates a printout of each variable within dset that includes the variable name, the units, and an extended description of the variable (if available). Parameters ---------- dset : xarray.Dataset Target dataset. It is possible to call `display_vars` on an unformatted `dset` e.g., display_vars(xr.open_dataset(file)), or on a formatted `dset` e.g., display_vars(get_cmaq_metadata(xr.open_dataset(file))). var_dsec : string, default='var_desc' Name of the attribute for the xarray.DataArray instances within `dset` which contains a description of the variable. str_incl : string, default=None String pattern to use for filtering. Only printout variables which include this pattern. str_excl : string, default=None String pattern to use for filtering. Only printout variables which do not include this pattern. Returns ------- None See Also ------- cmaq.get_cmaq_metadata \"\"\" data_vars = [ x . strip () for x in dset . data_vars ] # Perform filtering of data variables if str_incl is not None : print ( f \"Including Pattern: { str_incl } \" ) data_vars = [ x for x in data_vars if str_incl in x ] if str_excl is not None : print ( f \"Excluding Pattern: { str_excl } \" ) data_vars = [ x for x in data_vars if str_excl not in x ] var = \"VARNAME\" units = \"UNITS\" desc = \"DESCRIPTION\" print ( \"-\" * 80 ) print ( f \"| { var : 16 } | { units : 16 } | { desc } \" ) print ( \"-\" * 80 ) ct = 1 for var in data_vars : desc = \"\" units = \"\" try : desc = getattr ( dset [ var ], var_dsec ) except Exception : pass try : units = dset [ var ] . units except Exception : pass print ( f \"| { var : 16 } | { units : 16 } | { desc } \" ) if ct % 6 == 0 : print ( \"-\" * 80 ) ct += 1 return None","title":"display_vars"}]}